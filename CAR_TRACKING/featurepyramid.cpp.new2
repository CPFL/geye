///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////Car tracking project with laser_radar_data_fusion/////////////////////////////////////////
//////////////////////////////////////////////////////////////////////Copyright 2009-10 Akihiro Takeuchi///////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////featurepyramid.cpp   calculate HOG-feature pyramid ///////////////////////////////////////////////////////////

//OpenCV library
//#include "cv.h"			
//#include "cxcore.h"
//#include "highgui.h"	
#include "cv.h"
#include "highgui.h"
#include "cxcore.h"
#ifdef _DEBUG
    //Debugモードの場合
    #pragma comment(lib,"cv200d.lib") 
    #pragma comment(lib,"cxcore200d.lib") 
    #pragma comment(lib,"cvaux200d.lib") 
    #pragma comment(lib,"highgui200d.lib") 
#else
    //Releaseモードの場合
    #pragma comment(lib,"cv200.lib") 
    #pragma comment(lib,"cxcore200.lib") 
    #pragma comment(lib,"cvaux200.lib") 
    #pragma comment(lib,"highgui200.lib") 
#endif
//C++ library
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include <windows.h>
//#include <process.h>
#include <time.h>
#include <iostream>
using namespace std;

//Header files
#include "MODEL_info.h"		//File information
#include "Common.h"

#include "switch_float.h"
#include <cuda.h>
#include "drvapi_error_string.h"

extern CUdevice *dev;
extern CUcontext *ctx;
extern CUfunction *func_calc_feature;
extern CUmodule *module;


#ifndef WIN32
#define __stdcall void*
typedef void *HANDLE;
typedef long LONG_PTR;
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#endif


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//definition of constant
#define eps 0.0001

//definition of sin and cos
const FLOAT Hcos[9] = {1.0000 , 0.9397, 0.7660, 0.5000, 0.1736, -0.1736, -0.5000, -0.7660, -0.9397};
const FLOAT Hsin[9] = {0.0000 , 0.3420, 0.6428, 0.8660, 0.9848, 0.9848, 0.8660, 0.6428, 0.3420};

//definition of structure
struct thread_data {
	FLOAT *IM;
	int    ISIZE[3];
	int    FSIZE[2];
	int    F_C;
	int    sbin;
	FLOAT *Out;
};

//inline functions

static inline int   max_i(int x,int y); //return maximum number (integer)
static inline int   min_i(int x,int y); //return minimum number (integer)
static inline FLOAT min_2(FLOAT x);     //compare FLOAT with 0.2

//initialization functions 
FLOAT *ini_scales(Model_info *MI,IplImage *IM,int X,int Y); //initialize scales (extended to main)
int   *ini_featsize(Model_info *MI);                        //initialize feature size information matrix (extended to main)

//subfunction
FLOAT *Ipl_to_FLOAT(IplImage *Input);                                             //get intensity data (FLOAT) of input
void   free_features(FLOAT **features,Model_info *MI);                            //release features
FLOAT *calc_feature(FLOAT *SRC,int *ISIZE,int *FTSIZE,int sbin);                  //calculate HOG features
FLOAT *calc_feature_byGPU(FLOAT *SRC,int *ISIZE,int *FTSIZE,int sbin);                  //calculate HOG features
void   ini_thread_data(thread_data *TD,FLOAT *IM,int *INSIZE,int sbin,int level); //for thread-initialization
//unsigned __stdcall feat_calc(void *thread_arg);												//for thread_process													
void* feat_calc(void *thread_arg); //for thread_process

//main function to calculate feature pyramid
FLOAT **calc_f_pyramid(IplImage *Image,Model_info *MI,int *FTSIZE,FLOAT *scale);		//calculate feature pyramid (extended to detect.c)


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//external function

//resize.cpp
extern FLOAT *resize(FLOAT *src,int *sdims,int *odims,FLOAT scale);						//resize image 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//inline functions 

//return maximum number (integer)
static inline int max_i(int x,int y) {return (x >= y ? x : y); }

//return minimum number (integer)
static inline int min_i(int x,int y) {return (x <= y ? x : y); }

//return minimum number (FLOAT)
static inline FLOAT min_2(FLOAT x) {return (x <= 0.2 ? x :0.2); }


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//initialization functions

//initialize scales
FLOAT *ini_scales(Model_info *MI,IplImage *IM,int X,int Y) //X,Y length of image 
{

	int interval,max_scale;

	if(MI->ini)
	{
		//calculate max scale
		//MI->interval/=2;	//reduce calculation time
		const int sbin = MI->sbin;
		interval = MI->interval;
		const FLOAT sc = pow(2.0,(1/(double)interval));//縮小比を表している。
		const FLOAT minsize = FLOAT(min_i(X,Y));
		const int numcomponent = MI->numcomponent;
		//max_scale = 1+int(floor(log(minsize/(5*FLOAT(sbin)))/log(sc)));
		max_scale = 36;
		const int L_NUM = interval+max_scale;

		FLOAT MRY =(FLOAT)MI->rsize[0];
		FLOAT MRX =(FLOAT)MI->rsize[1];
		   
		for(int kk=1;kk<numcomponent;kk++)
		{
			if(MI->rsize[kk*2]<MRY) MRY=MI->rsize[kk*2];
			if(MI->rsize[kk*2+1]<MRX) MRX=MI->rsize[kk*2+1];
		}

		MRY/=2;
		MRX/=2;

		FLOAT height =(FLOAT)IM->height/(FLOAT)sbin;
		FLOAT width = (FLOAT)IM->width/(FLOAT)sbin;
		FLOAT sc_step =1/sc;   //縮小率

		for(int kk=0;kk<L_NUM;kk++)
		{
			height*=sc_step;
			width*=sc_step;
			if(height<MRY || width<MRX)
			{
				max_scale = kk-interval-1;
				break;
			}
		}

		if(max_scale<interval) max_scale = interval;
		MI->max_scale=max_scale;
		printf("max_scale:%d\n",max_scale);
		MI->IM_HEIGHT=IM->height;
		/*printf("高さ%d\n",MI->IM_HEIGHT);*/
		MI->IM_WIDTH=IM->width;
		/*printf("横%d\n",MI->IM_WIDTH);*/
		MI->ini=false;
	}
	else
	{
		interval = MI->interval;
		max_scale = MI->max_scale;
	}

	//return
	FLOAT *scales = (FLOAT*)calloc((max_scale+interval),sizeof(FLOAT));		//Model information
	return(scales);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//initialize feature size matrix

int *ini_featsize(Model_info *MI)
{
	const int LofFeat = MI->max_scale+MI->interval;
	int *featsize = (int*)calloc(LofFeat*2,sizeof(FLOAT)); // feature size information matrix
	return(featsize);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//calculate HOG features from Image
//HOG features are calculated for each block(BSL*BSL pixels)
FLOAT *calc_feature
(
 FLOAT *SRC,                    // resized image
 int *ISIZE,                    // resized image size (3 dimension)
 int *FTSIZE,                   // size of feature(output)
 int sbin                       // 各フィルタ用ブロックサイズ決定要因
 )
{
  /* input size */
	const int height  = ISIZE[0]; //{268,268,134,67,233,117,203,203,177,154,89,203,154,77}
	const int width   = ISIZE[1]; //{448,112,224,390,195,340,170,296,257,148,340,257,129}
	const int dims[2] = {height, width};

	/* size of Histgrams and Norm calculation space size */
	const int blocks[2] = {(int)floor(double(height)/double(sbin)+0.5), (int)floor(double(width)/double(sbin)+0.5)}; //{67,112}....sbine=4


	/* Output features size(Output) */
    int out[3] = {max_i(blocks[0]-2, 0), max_i(blocks[1]-2, 0), 27+4};

	/* Visible range (eliminate border blocks) */
	const int visible[2] = {blocks[0]*sbin, blocks[1]*sbin};

	/* HOG Histgram and Norm */
    FLOAT *hist = (FLOAT *)calloc(blocks[0]*blocks[1]*18, sizeof(FLOAT)); // HOG histgram
	FLOAT *norm = (FLOAT *)calloc(blocks[0]*blocks[1], sizeof(FLOAT));    // Norm

	/* feature(Output) */
    FLOAT *feat = (FLOAT *)calloc(out[0]*out[1]*out[2], sizeof(FLOAT));


    for (int x=1; x<visible[1]-1; x++) {
      for (int y=1; y<visible[0]-1; y++) {

        /* first color channel */
        FLOAT *s  = SRC + min_i(x, dims[1]-2)*dims[0] + min_i(y, dims[0]-2);
        FLOAT  dy = *(s+1) - *(s-1);
        FLOAT  dx = *(s+dims[0]) - *(s-dims[0]);
        FLOAT  v  = dx*dx + dy*dy;

        /* second color channel */
        s += dims[0]*dims[1];
        FLOAT dy2 = *(s+1) - *(s-1);
        FLOAT dx2 = *(s+dims[0]) - *(s-dims[0]);
        FLOAT v2  = dx2*dx2 + dy2*dy2;

        /* third color channel */
        s += dims[0]*dims[1];
        FLOAT dy3 = *(s+1) - *(s-1);
        FLOAT dx3 = *(s+dims[0]) - *(s-dims[0]);
        FLOAT v3  = dx3*dx3 + dy3*dy3;

        /* pick channel with strongest gradient */
        if (v2 > v) {
          v  = v2;
          dx = dx2;
          dy = dy2;
        }
        if (v3 > v) {
          v  = v3;
          dx = dx3;
          dy = dy3;
        }

        /* snap to one of 18 orientations */
        FLOAT best_dot = 0;
        int   best_o   = 0;
        for (int o=0; o<9; o++) {
          FLOAT dot = Hcos[o]*dx + Hsin[o]*dy; 

          if (dot > best_dot) {
            best_dot = dot;
            best_o   = o;
          }
          else if (-dot > best_dot) {
            best_dot = -dot;
            best_o   = o + 9;
          }

        }

        /*add to 4 histgrams aroud pixel using linear interpolation*/
        FLOAT xp  = ((FLOAT)x+0.5)/(FLOAT)sbin - 0.5;
        FLOAT yp  = ((FLOAT)y+0.5)/(FLOAT)sbin - 0.5;
        int   ixp = (int)floor(xp);
        int   iyp = (int)floor(yp);
        FLOAT vx0 = xp - ixp;
        FLOAT vy0 = yp - iyp;
        FLOAT vx1 = 1.0 - vx0;
        FLOAT vy1 = 1.0 - vy0;
        v = sqrt(v);

        if (ixp >= 0 && iyp >= 0) {
          *(hist + ixp*blocks[0] + iyp + best_o*blocks[0]*blocks[1]) += vx1*vy1*v;
        }

        if (ixp+1 < blocks[1] && iyp >= 0) {
          *(hist + (ixp+1)*blocks[0] + iyp + best_o*blocks[0]*blocks[1]) += vx0*vy1*v;
        }

        if (ixp >= 0 && iyp+1 < blocks[0]) {
          *(hist + ixp*blocks[0] + (iyp+1) + best_o*blocks[0]*blocks[1]) += vx1*vy0*v;
        }

        if (ixp+1 < blocks[1] && iyp+1 < blocks[0]) {
          *(hist + (ixp+1)*blocks[0] + (iyp+1) + best_o*blocks[0]*blocks[1]) += vx0*vy0*v;
        }
      }
    }

    /* compute energy in each block by summing over orientations */
#if 1
    for (int o=0; o<9; o++) {
      FLOAT *src1 = hist + o*blocks[0]*blocks[1];
      FLOAT *src2 = hist + (o+9)*blocks[0]*blocks[1];
      FLOAT *dst  = norm;
      FLOAT *end  = norm + blocks[0]*blocks[1];

      while(dst < end) {
        *(dst++) += (*src1 + *src2) * (*src1 + *src2);
        src1++;
        src2++;
      }
    }
#else
    for (int o=0; o<18; o++) {
      FLOAT *src1 = hist + o*blocks[0]*blocks[1];
      FLOAT *dst  = norm;
      FLOAT *end  = norm + blocks[0]*blocks[1];

      while(dst < end) {
        *(dst++) += (*src1) * (*src1);
        src1++;
      }
    }
#endif

    /* compute featuers */
    for (int x=0; x<out[1]; x++) {
      for (int y=0; y<out[0]; y++) {
        FLOAT *dst = feat + x*out[0] + y;
        FLOAT *src, *p, n1, n2, n3, n4;

        p = norm + (x+1)*blocks[0] + y+1;
        n1 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        p = norm + (x+1)*blocks[0] + y;
        n2 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        p = norm + x*blocks[0] + y+1;
        n3 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        p = norm + x*blocks[0] + y;
        n4 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        FLOAT t1 = 0;
        FLOAT t2 = 0;
        FLOAT t3 = 0;
        FLOAT t4 = 0;

        /* contrast-sensitive features */
        src = hist + (x+1)*blocks[0] + (y+1);
        for (int o=0; o<18; o++) {
          FLOAT h1 = min_2(*src * n1);
          FLOAT h2 = min_2(*src * n2);
          FLOAT h3 = min_2(*src * n3);
          FLOAT h4 = min_2(*src * n4);

          *dst = 0.5 * (h1 + h2 + h3 + h4);

          t1 += h1;
          t2 += h2;
          t3 += h3;
          t4 += h4;

          dst += out[0]*out[1];
          src += blocks[0]*blocks[1];
        }

        /* contrast-insensitive features */
        src = hist + (x+1)*blocks[0] + (y+1);
        for (int o=0; o<9; o++) {
          FLOAT sum = *src + *(src + 9*blocks[0]*blocks[1]);
          FLOAT h1 = min_2(sum * n1);
          FLOAT h2 = min_2(sum * n2);
          FLOAT h3 = min_2(sum * n3);
          FLOAT h4 = min_2(sum * n4);

          *dst = 0.5 * (h1 + h2 + h3 + h4);

          dst += out[0]*out[1];
          src += blocks[0]*blocks[1];
        }

        /* texture features */
        *dst = 0.2357 * t1;
        dst += out[0]*out[1];

        *dst = 0.2357 * t2;
        dst += out[0]*out[1];

        *dst = 0.2357 * t3;
        dst += out[0]*out[1];

        *dst = 0.2357 * t4;
      }
    }
      
    free(hist);
    free(norm);

	/* size of feature(output) */
	*FTSIZE     = out[0];
    *(FTSIZE+1) = out[1];

	
    //	printf("feat%f\n",*(feat));
	return(feat);

}


/* error handling macro */
#define MY_CUDA_CHECK(res, text)                \
  if ((res) != CUDA_SUCCESS) {                  \
    printf("%s failed: res = %d\n->%s\n", (text), (res), getCudaDrvErrorString((res))); \
  exit(1);                                      \
  }

//#define DEBUG
#define USE_TEX

FLOAT *calc_feature_byGPU
(
 FLOAT *SRC,                    // resized image
 int *ISIZE,                    // resized image size (3 dimension)
 int *FTSIZE,                   // size of feature(output)
 int sbin                       // 各フィルタ用ブロックサイズ決定要因
 )
{
  /* rename argument */
  FLOAT *resized_image      = SRC;
  int   *resized_image_size = ISIZE;

  /* input size */
  const int height  = ISIZE[0]; //{268,268,134,67,233,117,203,203,177,154,89,203,154,77}
  const int width   = ISIZE[1]; //{448,112,224,390,195,340,170,296,257,148,340,257,129}
  const int dims[2] = {height, width};

  /* size of Histgrams and Norm calculation space size */
  const int blocks[2] = {(int)floor(double(height)/double(sbin)+0.5), (int)floor(double(width)/double(sbin)+0.5)}; //{67,112}....sbine=4
  
  /* Output features size(Output) */
  int out[3] = {max_i(blocks[0]-2, 0), max_i(blocks[1]-2, 0), 27+4};
  
  /* Visible range (eliminate border blocks) */
  const int visible[2] = {blocks[0]*sbin, blocks[1]*sbin};
  
  /* HOG Histgram and Norm */
  FLOAT *hist = (FLOAT *)calloc(blocks[0]*blocks[1]*18, sizeof(FLOAT)); // HOG histgram
  FLOAT *norm = (FLOAT *)calloc(blocks[0]*blocks[1], sizeof(FLOAT));    // Norm
  
  /* feature(Output) */
  FLOAT *feat = (FLOAT *)calloc(out[0]*out[1]*out[2], sizeof(FLOAT));
  
  
#ifndef DEBUG

  CUresult res;
  
  /* allocate GPU memory */
  CUdeviceptr resized_image_dev;
  res = cuMemAlloc(&resized_image_dev, resized_image_size[0]*resized_image_size[1]*resized_image_size[2]*sizeof(FLOAT));
  MY_CUDA_CHECK(res, "cuMemAlloc(resized_image_dev)");
  
  
  CUdeviceptr resized_image_size_dev;
  res = cuMemAlloc(&resized_image_size_dev, 3*sizeof(int));
  MY_CUDA_CHECK(res, "cuMemAlloc(resized_image_size_dev)");
  
  CUdeviceptr hist_dev;
  res = cuMemAlloc(&hist_dev, blocks[0]*blocks[1]*18*sizeof(FLOAT));
  MY_CUDA_CHECK(res, "cuMemAlloc(hist_dev)");
  
  /*upload data to GPU*/
  res = cuMemcpyHtoD(resized_image_dev, resized_image, resized_image_size[0]*resized_image_size[1]*resized_image_size[2]*sizeof(FLOAT));
  MY_CUDA_CHECK(res, "cuMemcpyHtoD(resized_image_dev)");
  
  res = cuMemcpyHtoD(resized_image_size_dev, resized_image_size, 3*sizeof(int));
  MY_CUDA_CHECK(res, "cuMemcpyHtoD(resized_image_size_dev)");
  
  res = cuMemcpyHtoD(hist_dev, hist, blocks[0]*blocks[1]*18*sizeof(FLOAT));
  MY_CUDA_CHECK(res, "cuMemcpyHtoD(hist_dev)");


  
#ifdef USE_TEX

  /* get handle to a texture memory on GPU */
  CUtexref resized_image_texref, resized_image_size_texref;
  if (sizeof(FLOAT) == sizeof(float))
    {
      res = cuModuleGetTexRef(&resized_image_texref, module[0], "resized_image");
      MY_CUDA_CHECK(res, "cuModuleGetTexRef(resized_image)");
    }
  else
    {
      res = cuModuleGetTexRef(&resized_image_texref, module[0], "resized_image_double");
      MY_CUDA_CHECK(res, "cuModuleGetTexRef(resized_image)");
    }
  
  res = cuModuleGetTexRef(&resized_image_size_texref, module[0], "resized_image_size");
  MY_CUDA_CHECK(res, "cuModuleGetTexRef(resized_image_size)");
  
  
  /* bind to texture memory on GPU */
  res = cuTexRefSetAddress(NULL, resized_image_texref, resized_image_dev, resized_image_size[0]*resized_image_size[1]*resized_image_size[2]*sizeof(FLOAT));
  MY_CUDA_CHECK(res, "cuTexRefAddress(resized_image_dev)");
  
  res = cuTexRefSetAddress(NULL, resized_image_size_texref, resized_image_size_dev, 3*sizeof(int));
  MY_CUDA_CHECK(res, "cuTexRefAddress(resized_image_size_dev)");
  
  
  /* texture memory configuration */
  res = cuTexRefSetFlags(resized_image_texref, CU_TRSF_NORMALIZED_COORDINATES);
  MY_CUDA_CHECK(res, "cuTexRefSetFlags(resized_image_texref)");
  
  res = cuTexRefSetFlags(resized_image_size_texref, CU_TRSF_NORMALIZED_COORDINATES);
  MY_CUDA_CHECK(res, "cuTexRefSetFlags(resized_image_size_texref)");
  
  if (sizeof(FLOAT) == sizeof(float)) 
    {
      res = cuTexRefSetFormat(resized_image_texref, CU_AD_FORMAT_FLOAT, 1);
      MY_CUDA_CHECK(res, "cuTexRefSetFormat(resized_image_texref)");
    }
  else
    {
      res = cuTexRefSetFormat(resized_image_texref, CU_AD_FORMAT_UNSIGNED_INT32, 2);
      MY_CUDA_CHECK(res, "cuTexRefSetFormat(resized_image_texref)");
    }
  
  res = cuTexRefSetFormat(resized_image_size_texref, CU_AD_FORMAT_SIGNED_INT32, 1);
  MY_CUDA_CHECK(res, "cuTexRefSetFormat(resized_image_size_texref)");
  
  
  void *kernel_args[] = {
    &hist_dev,
    (void *)&sbin
  };

#else

  void *kernel_args[] = {
    &resized_image_dev,
    &resized_image_size_dev,
    &hist_dev,
    (void *)&sbin
  };

#endif    
  
  /* decide CUDA block shape */
  int max_thread_num = 0;
  res =cuDeviceGetAttribute(&max_thread_num, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, dev[0]);
  MY_CUDA_CHECK(res, "cuDeviceGetAttribure()");
  
  max_thread_num = 16;

  int thread_num_x = (visible[1]-1 < sqrt(max_thread_num)) ? 
    visible[1]-1 : sqrt(max_thread_num);
  int thread_num_y = (visible[0]-1 < sqrt(max_thread_num)) ? 
    visible[0]-1 : sqrt(max_thread_num);
  
  int block_num_x = (visible[1]-1) / thread_num_x;
  int block_num_y = (visible[0]-1) / thread_num_y;
  if ((visible[1]-1) % thread_num_x != 0) block_num_x++;
  if ((visible[0]-1) % thread_num_y != 0) block_num_y++;
  
  int sharedMemBytes = 0;
  
  /* execute GPU function */ 
  res = cuLaunchKernel(
                       func_calc_feature[0], // call function
                       block_num_x,          // gridDimX
                       block_num_y,          // gridDimY
                       1,                    // gridDimZ
                       thread_num_x,         // blockDimX
                       thread_num_y,         // blockDimY
                       1,                    // blockDimZ
                       sharedMemBytes,       // sharedMemBytes
                       NULL,                 // hStream
                       kernel_args,          // kernel Parameter
                       NULL                  // extra
                       );
  MY_CUDA_CHECK(res, "cuLaunchKernel(calc_feature)");
  
  
  /* synchronize GPU threads */
  res = cuCtxSynchronize();
  MY_CUDA_CHECK(res, "cuCtxSynchronize(calc_feat)");
  
  /* download data from GPU */
  res = cuMemcpyDtoH((void *)hist, hist_dev, blocks[0]*blocks[1]*18*sizeof(FLOAT));
  MY_CUDA_CHECK(res, "cuMemcpyDtoH(hist_dev)");
  
  
  /* free GPU memory */
  res = cuMemFree(resized_image_dev);
  MY_CUDA_CHECK(res, "cuMemFree(resized_image_dev)");
  
  res = cuMemFree(resized_image_size_dev);
  MY_CUDA_CHECK(res, "cuMemFree(resized_image_size_dev)");
  
  res = cuMemFree(hist_dev);
  MY_CUDA_CHECK(res, "cuMemFree(hist_dev)");
  
#else

  for (int x=1; x<visible[1]-1; x++) {
    for (int y=1; y<visible[0]-1; y++) {
      
      /* first color channel */
      FLOAT *s  = SRC + min_i(x, dims[1]-2)*dims[0] + min_i(y, dims[0]-2);
      FLOAT  dy = *(s+1) - *(s-1);
      FLOAT  dx = *(s+dims[0]) - *(s-dims[0]);
      FLOAT  v  = dx*dx + dy*dy;

      /* second color channel */
      s += dims[0]*dims[1];
      FLOAT dy2 = *(s+1) - *(s-1);
      FLOAT dx2 = *(s+dims[0]) - *(s-dims[0]);
      FLOAT v2  = dx2*dx2 + dy2*dy2;
      
      /* third color channel */
      s += dims[0]*dims[1];
      FLOAT dy3 = *(s+1) - *(s-1);
      FLOAT dx3 = *(s+dims[0]) - *(s-dims[0]);
      FLOAT v3  = dx3*dx3 + dy3*dy3;

      /* pick channel with strongest gradient */
      if (v2 > v) {
        v  = v2;
        dx = dx2;
        dy = dy2;
      }
      if (v3 > v) {
        v  = v3;
        dx = dx3;
        dy = dy3;
      }
    
      /* snap to one of 18 orientations */
      FLOAT best_dot = 0;
      int   best_o   = 0;
      for (int o=0; o<9; o++) {
        FLOAT dot = Hcos[o]*dx + Hsin[o]*dy; 
        
        if (dot > best_dot) {
          best_dot = dot;
          best_o   = o;
        }
        else if (-dot > best_dot) {
          best_dot = -dot;
          best_o   = o + 9;
        }
        
      }
      
      /*add to 4 histgrams aroud pixel using linear interpolation*/
      FLOAT xp  = ((FLOAT)x+0.5)/(FLOAT)sbin - 0.5;
      FLOAT yp  = ((FLOAT)y+0.5)/(FLOAT)sbin - 0.5;
      int   ixp = (int)floor(xp);
      int   iyp = (int)floor(yp);
      FLOAT vx0 = xp - ixp;
      FLOAT vy0 = yp - iyp;
      FLOAT vx1 = 1.0 - vx0;
      FLOAT vy1 = 1.0 - vy0;
      v = sqrt(v);
      
      if (ixp >= 0 && iyp >= 0) {
        *(hist + ixp*blocks[0] + iyp + best_o*blocks[0]*blocks[1]) += vx1*vy1*v;
      }
      
      if (ixp+1 < blocks[1] && iyp >= 0) {
        *(hist + (ixp+1)*blocks[0] + iyp + best_o*blocks[0]*blocks[1]) += vx0*vy1*v;
      }
      
      if (ixp >= 0 && iyp+1 < blocks[0]) {
        *(hist + ixp*blocks[0] + (iyp+1) + best_o*blocks[0]*blocks[1]) += vx1*vy0*v;
      }
      
      if (ixp+1 < blocks[1] && iyp+1 < blocks[0]) {
        *(hist + (ixp+1)*blocks[0] + (iyp+1) + best_o*blocks[0]*blocks[1]) += vx0*vy0*v;
      }
    }
  }
#endif
  




























    /* compute energy in each block by summing over orientations */
#if 1
    for (int o=0; o<9; o++) {
      FLOAT *src1 = hist + o*blocks[0]*blocks[1];
      FLOAT *src2 = hist + (o+9)*blocks[0]*blocks[1];
      FLOAT *dst  = norm;
      FLOAT *end  = norm + blocks[0]*blocks[1];

      while(dst < end) {
        *(dst++) += (*src1 + *src2) * (*src1 + *src2);
        src1++;
        src2++;
      }
    }
#else
    for (int o=0; o<18; o++) {
      FLOAT *src1 = hist + o*blocks[0]*blocks[1];
      FLOAT *dst  = norm;
      FLOAT *end  = norm + blocks[0]*blocks[1];

      while(dst < end) {
        *(dst++) += (*src1) * (*src1);
        src1++;
      }
    }
#endif

    /* compute featuers */
    for (int x=0; x<out[1]; x++) {
      for (int y=0; y<out[0]; y++) {
        FLOAT *dst = feat + x*out[0] + y;
        FLOAT *src, *p, n1, n2, n3, n4;

        p = norm + (x+1)*blocks[0] + y+1;
        n1 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        p = norm + (x+1)*blocks[0] + y;
        n2 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        p = norm + x*blocks[0] + y+1;
        n3 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        p = norm + x*blocks[0] + y;
        n4 = 1.0 / sqrt(*p + *(p+1) + *(p+blocks[0]) + *(p+blocks[0]+1) + eps);

        FLOAT t1 = 0;
        FLOAT t2 = 0;
        FLOAT t3 = 0;
        FLOAT t4 = 0;

        /* contrast-sensitive features */
        src = hist + (x+1)*blocks[0] + (y+1);
        for (int o=0; o<18; o++) {
          FLOAT h1 = min_2(*src * n1);
          FLOAT h2 = min_2(*src * n2);
          FLOAT h3 = min_2(*src * n3);
          FLOAT h4 = min_2(*src * n4);

          *dst = 0.5 * (h1 + h2 + h3 + h4);

          t1 += h1;
          t2 += h2;
          t3 += h3;
          t4 += h4;

          dst += out[0]*out[1];
          src += blocks[0]*blocks[1];
        }

        /* contrast-insensitive features */
        src = hist + (x+1)*blocks[0] + (y+1);
        for (int o=0; o<9; o++) {
          FLOAT sum = *src + *(src + 9*blocks[0]*blocks[1]);
          FLOAT h1 = min_2(sum * n1);
          FLOAT h2 = min_2(sum * n2);
          FLOAT h3 = min_2(sum * n3);
          FLOAT h4 = min_2(sum * n4);

          *dst = 0.5 * (h1 + h2 + h3 + h4);

          dst += out[0]*out[1];
          src += blocks[0]*blocks[1];
        }

        /* texture features */
        *dst = 0.2357 * t1;
        dst += out[0]*out[1];

        *dst = 0.2357 * t2;
        dst += out[0]*out[1];

        *dst = 0.2357 * t3;
        dst += out[0]*out[1];

        *dst = 0.2357 * t4;
      }
    }
      
    free(hist);
    free(norm);

	/* size of feature(output) */
	*FTSIZE     = out[0];
    *(FTSIZE+1) = out[1];

	
    //	printf("feat%f\n",*(feat));
	return(feat);

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//sub functions

// get pixel-intensity(FLOAT)  of image(IplImage)

FLOAT *Ipl_to_FLOAT(IplImage *Input)	//get intensity data (FLOAT) of input
{
	const int width     = Input->width;
	printf("%d\n",width);
	const int height    = Input->height;
	printf("%d\n",height);
	const int nChannels = Input->nChannels;
	printf("%d\n",nChannels);
	const int SQ        = height*width;
	const int WS        = Input->widthStep;

	FLOAT *Output = (FLOAT *)malloc(sizeof(FLOAT)*height*width*nChannels);
	printf("%d",height*width*nChannels);

	FLOAT *R     = Output;
	FLOAT *G     = Output + SQ;
	FLOAT *B     = Output + 2*SQ;
	char  *IDATA = Input->imageData;

	//pick intensity of pixel (color)
	for(int x=0; x<width; x++)
	{
		int XT = x*3;
		for(int y=0; y<height; y++)
		{
			int pp = WS*y + XT;
			*(B++) = (FLOAT)(unsigned char)IDATA[pp];	//B
			pp++;
			*(G++) = (FLOAT)(unsigned char)IDATA[pp];	//G
			pp++;
			*(R++) = (FLOAT)(unsigned char)IDATA[pp];	//R
		}
	}
	return(Output);
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// feature calculation
//unsigned __stdcall feat_calc(void *thread_arg) 
void* feat_calc(void *thread_arg) 
{
  thread_data *args  = (thread_data *)thread_arg;
  FLOAT       *IM    = args->IM;
  int         *ISIZE = args->ISIZE;
  int         *FSIZE = args->FSIZE;
  int          sbin  = args->sbin;
  //FLOAT       *Out   = calc_feature(args->IM, args->ISIZE, args->FSIZE, args->sbin);			
  FLOAT       *Out   = calc_feature_byGPU(args->IM, args->ISIZE, args->FSIZE, args->sbin);			
  args->Out = Out;			
  //_endthreadex(0);
  //return(0);

  //  pthread_exit((void*)thread_arg);

}

//void initialize thread data
void ini_thread_data(thread_data *TD,FLOAT *IM,int *INSIZE,int sbin,int level)
{
	
	TD->IM       = IM; 
    memcpy(TD->ISIZE, INSIZE, sizeof(int)*3);
	TD->FSIZE[0] = 0;
	TD->FSIZE[1] = 0;
	TD->sbin     = sbin;
	TD->F_C      = level;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//calculate feature pyramid (extended to main.cpp)

//calculate feature pyramid
FLOAT **calc_f_pyramid
(
 IplImage *Image,
 Model_info *MI,
 int *FTSIZE,
 FLOAT *scale
 )	//calculate feature pyramid
{
  /* constant parameters */
  const int   max_scale = MI->max_scale;
  const int   interval  = MI->interval;
  const int   sbin      = MI->sbin;                     // root filter用ブロックサイズ決定要因
  const int   sbin2     = (int)floor((double)sbin/2.0); // part filter用ブロックサイズ決定要因
  const int   LEN       = max_scale + interval;
  const FLOAT sc        = pow(2, (1.0/(double)interval));

  int org_image_size[3]  = {Image->height, Image->width, Image->nChannels}; // original image size // (元INSIZE)
  
  /* Original image (FLOAT) */
  FLOAT *org_image = Ipl_to_FLOAT(Image); // IplImageから各チャンネルの輝度を抽出 // (元D_I)
  
  /* features */
  FLOAT **feat = (FLOAT**)malloc(sizeof(FLOAT*)*LEN); //Model information
  
  /* thread for feature calculation */
  unsigned     threadID;
  thread_data *td = (thread_data *)calloc(LEN, sizeof(thread_data));	
  pthread_t   *ts = (pthread_t *)calloc(LEN, sizeof(HANDLE));	
  
  FLOAT **resized_image      = (FLOAT**)calloc(LEN, sizeof(FLOAT*)); // リサイズされた画像 // (元RIM_S)
  int    *resized_image_size = (int*)calloc(LEN*3, sizeof(int));     // リサイズされた画像のサイズ // (元RI_S)
  int     t_count            = 0;
  
  /* calculate resized image */
  /* resize画像がLEN枚生成される */
  for(int ii=0; ii<interval; ii++) 
    {
      FLOAT st = 1.0/pow(sc, ii);

      resized_image[ii] = resize(
                                 org_image,
                                 org_image_size, 
                                 resized_image_size + ii*3,
                                 st
                                 );

      resized_image[ii+interval] = resized_image[ii];
      memcpy(resized_image_size + (ii+interval)*3, resized_image_size + (ii)*3, 3*sizeof(int));

      *(scale+ii)          = st*2; //save scale
      *(scale+ii+interval) = st;   //save scale

      /* remained resolutions (for root_only) */
      for(int jj=ii+interval; jj<max_scale; jj+=interval)
        {	
          resized_image[jj+interval] = resize(
                                              resized_image[jj],
                                              resized_image_size + (jj)*3,
                                              resized_image_size + (jj+interval)*3,
                                              0.5
                                              ); //resize image (FLOAT)

          *(scale + jj + interval) = 0.5*(*(scale + jj)); //save scale
        }

    }

  CUresult res;
  res = cuCtxSetCurrent(ctx[0]);
  if (res != CUDA_SUCCESS) {
    printf("cuCtxCurrent(ctx[0]) failed: res = %d\n->%s\n", res, getCudaDrvErrorString(res));
    exit(1);
  }

  
  /* calculate HOG feature for each resized image */
  for(int ii=0; ii<interval; ii++)
    {
      FLOAT st = 1.0/pow(sc, ii);

      /* ルートフィルタ用特徴量(全体的特徴量)？ */
      /* "first" 2x interval */
      ini_thread_data(
                      &td[t_count], 
                      resized_image[ii], 
                      resized_image_size + ii*3,
                      sbin2, 
                      ii
                      );  //initialize thread

      // if( pthread_create(&ts[t_count], NULL, feat_calc, (void*)&td[t_count]))
      //   {printf("Error thread\n"); exit(0);}
      feat_calc((void *)&td[t_count]);
      t_count++;
      
      /* パートフィルタ用特徴量(局所的特徴量)？ */
      /* "second" 1x interval */
      
      ini_thread_data(
                      &td[t_count], 
                      resized_image[ii+interval], 
                      resized_image_size + ii*3,
                      sbin, 
                      ii+interval
                      );	//initialize thread

      // if(pthread_create(&ts[t_count], NULL, feat_calc, (void*)&td[t_count]))
      //   {printf("Error thread\n"); exit(0);}
      feat_calc((void *)&td[t_count]);
      t_count++;
      
      /* remained resolutions (for root_only) */
      for(int jj=ii+interval; jj<max_scale; jj+=interval)
        {	
          ini_thread_data(
                          &td[t_count], 
                          resized_image[jj+interval], 
                          resized_image_size + (jj+interval)*3,
                          sbin, 
                          jj+interval
                          ); //initialize thread

          // if(pthread_create(&ts[t_count], NULL, feat_calc, (void*)&td[t_count]))
          //   {printf("Error thread\n"); exit(0);}
          feat_calc((void *)&td[t_count]);          
          t_count++;
        }
    }


  /* get thread data */
  for(int ss=0; ss<LEN; ss++)
    {
      //pthread_join(ts[ss], NULL);
      feat[td[ss].F_C] = td[ss].Out; // ここで特徴量をひとつの配列にまとめる

      memcpy(&FTSIZE[td[ss].F_C*2], td[ss].FSIZE, sizeof(int)*2);

      //close(ts[ss]);
    }
  
  /* release original image */
  s_free(org_image);
  
  /* release resized image */
  for(int ss=0; ss<interval; ss++) s_free(resized_image[ss]);
  for(int ss=interval*2; ss<LEN; ss++) s_free(resized_image[ss]);
  s_free(resized_image);
  s_free(resized_image_size);

    
  /* release thread information */
  s_free(td);		
  s_free(ts);		
  
  return(feat);

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//release function
//release feature pyramid

void free_features(FLOAT **features,Model_info *MI)
{
	int LofFeat = MI->max_scale + MI->interval;
	if(features != NULL)
	{
		for (int ii=0; ii<LofFeat; ii++)
		{
			s_free(features[ii]);
		}
		s_free(features);
	}
}



